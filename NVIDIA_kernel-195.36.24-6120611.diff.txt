diff -ru usr/src/nv/Makefile.kbuild usr/src/nv.6120611/Makefile.kbuild
--- usr/src/nv/Makefile.kbuild	2010-04-22 20:40:43.000000000 -0700
+++ usr/src/nv.6120611/Makefile.kbuild	2010-06-08 07:51:02.147829142 -0700
@@ -165,7 +165,8 @@
  proc_dir_entry \
  INIT_WORK \
  acpi_walk_namespace \
- agp_memory
+ agp_memory \
+ scatterlist
 
 #
 # Miscellaneous NVIDIA kernel module build support targets. They are needed
diff -ru usr/src/nv/Makefile.nvidia usr/src/nv.6120611/Makefile.nvidia
--- usr/src/nv/Makefile.nvidia	2010-04-22 20:40:43.000000000 -0700
+++ usr/src/nv.6120611/Makefile.nvidia	2010-06-08 07:51:58.040355195 -0700
@@ -56,7 +56,8 @@
 	i2c_adapter \
 	smp_call_function \
 	acpi_evaluate_integer \
-	proc_dir_entry
+	proc_dir_entry \
+	scatterlist
 
 DEFINES+=$(EXTRA_DEFINES)
 
diff -ru usr/src/nv/conftest.sh usr/src/nv.6120611/conftest.sh
--- usr/src/nv/conftest.sh	2010-04-22 20:40:43.000000000 -0700
+++ usr/src/nv.6120611/conftest.sh	2010-06-08 07:50:23.346851935 -0700
@@ -1079,6 +1079,31 @@
             fi
         ;;
 
+        scatterlist)
+            #
+            # Determine if the 'scatterlist' structure has
+            # a 'page_link' member.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/types.h>
+            #include <linux/scatterlist.h>
+            int conftest_scatterlist(void) {
+                return offsetof(struct scatterlist, page_link);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_SCATTERLIST_HAS_PAGE" >> conftest.h
+                rm -f conftest$$.o
+                return
+            else
+                echo "#define NV_SCATTERLIST_HAS_PAGE" >> conftest.h
+                return
+            fi
+        ;;
+
     esac
 }
 
diff -ru usr/src/nv/nv-linux.h usr/src/nv.6120611/nv-linux.h
--- usr/src/nv/nv-linux.h	2010-04-22 20:40:40.000000000 -0700
+++ usr/src/nv.6120611/nv-linux.h	2010-06-08 07:50:23.346851935 -0700
@@ -334,14 +334,28 @@
 #define NV_MAX_RECURRING_WARNING_MESSAGES 10
 
 /* add support for iommu.
- * on x86_64 platforms, this uses the gart to remap pages that are > 32-bits
- * to < 32-bits.
+ * On the x86-64 platform, the driver may need to remap system
+ * memory pages via AMD K8/Intel VT-d IOMMUs if a given
+ * GPUs addressing capabilities are limited such that it can
+ * not access the original page directly. Examples of this
+ * are legacy PCI-E devices.
  */
-#if defined(NVCPU_X86_64) && !defined(GFP_DMA32)
+#if (defined(NVCPU_X86_64) && !defined(GFP_DMA32)) || defined(CONFIG_DMAR)
 #define NV_SG_MAP_BUFFERS 1
 extern int nv_swiotlb;
+
+#if defined(CONFIG_DMAR)
+#define NV_INTEL_IOMMU 1
+#else
+/*
+ * Limit use of IOMMU/SWIOTLB space to 60 MB, leaving 4 MB for the rest of 
+ * the system (assuming a 64 MB IOMMU/SWIOTLB).
+ * This is not required if Intel VT-d IOMMU is used to remap pages. 
+ */
+#define NV_NEED_REMAP_CHECK 1
 #define NV_REMAP_LIMIT_DEFAULT  (60 * 1024 * 1024)
 #endif
+#endif
 
 /* add support for software i/o tlb support.
  * normally, you'd expect this to be transparent, but unfortunately this is not
diff -ru usr/src/nv/nv-vm.c usr/src/nv.6120611/nv-vm.c
--- usr/src/nv/nv-vm.c	2010-04-22 20:40:39.000000000 -0700
+++ usr/src/nv.6120611/nv-vm.c	2010-06-08 07:50:23.346851935 -0700
@@ -102,8 +102,10 @@
 
 /* track how much memory has been remapped through the iommu/swiotlb */
 
+#if defined(NV_NEED_REMAP_CHECK)
 extern unsigned int nv_remap_count;
 extern unsigned int nv_remap_limit;
+#endif
 
 static inline int nv_map_sg(struct pci_dev *dev, struct scatterlist *sg)
 {
@@ -136,31 +138,27 @@
     unsigned int        num_pages
 )
 {
-    int force_remap = FALSE;
     struct scatterlist *sg_ptr = &page_list[0]->sg_list;
     unsigned int i;
     static int count = 0;
 
+#if defined(NV_SCATTERLIST_HAS_PAGE)
     sg_ptr->page = virt_to_page(base);
+#else
+    sg_ptr->page_link = virt_to_page(base);
+#endif
     sg_ptr->offset = (unsigned long)base & ~PAGE_MASK;
     sg_ptr->length  = num_pages * PAGE_SIZE;
 
-#if defined(DEBUG) && !defined(KERNEL_2_4)
-    /*
-     * XXX If the user specifically requested that the IOMMU
-     * be used, then override the address range check below
-     * and unconditionally call nv_map_sg() to remap the page(s).
-     */
-    force_remap = force_iommu;
-#endif
-
-    if (!force_remap && 
-        ((virt_to_phys(base) + sg_ptr->length - 1) & ~dev->dma_mask) == 0)
+#if !defined(NV_INTEL_IOMMU)
+    if (((virt_to_phys(base) + sg_ptr->length - 1) & ~dev->dma_mask) == 0)
     {
         sg_ptr->dma_address = virt_to_phys(base);
         goto done;
     }
+#endif
 
+#if defined(NV_NEED_REMAP_CHECK)
     if ((nv_remap_count + sg_ptr->length) > nv_remap_limit)
     {
         if (count < NV_MAX_RECURRING_WARNING_MESSAGES)
@@ -178,6 +176,7 @@
         }
         return 1;
     }
+#endif
 
     i = NV_MAP_SG_MAX_RETRIES;
     do {
@@ -190,7 +189,11 @@
             nv_unmap_sg(dev, sg_ptr);
 
             memset(&sg_tmp, 0, sizeof(struct scatterlist));
+#if defined(NV_SCATTERLIST_HAS_PAGE)
             sg_tmp.page = sg_ptr->page;
+#else
+            sg_tmp.page_link = sg_ptr->page_link;
+#endif
             sg_tmp.offset = sg_ptr->offset;
             sg_tmp.length = 2048;
 
@@ -215,8 +218,10 @@
         return -1;
     }
 
+#if defined(NV_NEED_REMAP_CHECK)
     if (sg_ptr->dma_address != virt_to_phys(base))
         nv_remap_count += sg_ptr->length;
+#endif
 
     // this is a bit of a hack to make contiguous allocations easier to handle
     // nv_sg_load below relies on the page_ptr addresses being filed in, as 
@@ -283,7 +288,9 @@
     {
         nv_unmap_sg(dev, sg_ptr);
         page_ptr->dma_addr = 0;
+#if defined(NV_NEED_REMAP_CHECK)
         nv_remap_count -= sg_ptr->length;
+#endif
     }
 }
 #endif  /* NV_SG_MAP_BUFFERS */
diff -ru usr/src/nv/nv.c usr/src/nv.6120611/nv.c
--- usr/src/nv/nv.c	2010-04-22 20:40:38.000000000 -0700
+++ usr/src/nv.6120611/nv.c	2010-06-08 07:50:23.350892195 -0700
@@ -129,9 +129,11 @@
 
 #if defined(NV_SG_MAP_BUFFERS)
 int nv_swiotlb = 0;
+#if defined(NV_NEED_REMAP_CHECK)
 unsigned int nv_remap_count;
 unsigned int nv_remap_limit;
 #endif
+#endif
 
 int nv_update_memory_types = 1;
 static int nv_mmconfig_failure_detected = 0;
@@ -1534,7 +1536,7 @@
         goto failed;
     }
 
-#if defined(NV_SG_MAP_BUFFERS)
+#if defined(NV_SG_MAP_BUFFERS) && defined(NV_NEED_REMAP_CHECK)
     rm_read_registry_dword(sp, nv, "NVreg", "RemapLimit", &nv_remap_limit);
 
     // allow an override, but use default if no override
@@ -1854,7 +1856,7 @@
             "NVRM: final KM memory usage: 0x%x bytes\n", km_usage);
     }
 #endif
-#if defined(NV_SG_MAP_BUFFERS)
+#if defined(NV_SG_MAP_BUFFERS) && defined(NV_NEED_REMAP_CHECK)
     if (nv_remap_count != 0)
     {
         nv_printf(NV_DBG_ERRORS,
